<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Renix MX — Encrypted Code</title>
  <style>
    :root { --bg:#0b0f14; --card:#121823; --text:#e6edf3; --muted:#9fb3c8; --accent:#7c5cff; --accent-2:#17c964; --danger:#ff5d5d; --border:#1f2a3a; }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;color:var(--text);background:radial-gradient(1200px 600px at 20% -10%,rgba(124,92,255,0.12),transparent 60%),radial-gradient(900px 500px at 120% 10%,rgba(23,201,100,0.10),transparent 60%),var(--bg)}
    .wrap{max-width:1000px;margin:40px auto;padding:24px}
    .title{font-size:clamp(24px,3vw,40px);font-weight:800;letter-spacing:0.3px;margin:0 0 6px}
    .subtitle{color:var(--muted);margin:0 0 24px}
    .grid{display:grid;gap:16px;grid-template-columns:1fr}
    @media(min-width:960px){.grid{grid-template-columns:1fr 1fr}}
    .card{background:linear-gradient(180deg,#121823,#0f141d);border:1px solid var(--border);border-radius:18px;padding:18px;box-shadow:0 10px 30px rgba(0,0,0,0.35)}
    .card h2{margin:0 0 12px;font-size:18px;letter-spacing:0.2px}
    textarea,input[type="text"],input[type="password"],select{width:100%;background:#0b111a;border:1px solid var(--border);color:var(--text);border-radius:14px;padding:12px 14px;font-size:15px;min-height:140px;resize:vertical}
    input[type="text"],input[type="password"],select{min-height:auto}
    select{appearance:none;background-image:url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%239fb3c8' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e");background-position:right 12px center;background-repeat:no-repeat;background-size:16px;padding-right:40px}
    .row{display:flex;gap:10px;flex-wrap:wrap}
    .method-row{display:flex;gap:10px;align-items:center;margin-bottom:12px}
    .method-row label{color:var(--muted);font-size:14px;min-width:80px}
    button{appearance:none;border:none;background:var(--accent);color:white;border-radius:12px;padding:10px 14px;font-weight:700;cursor:pointer;transition:transform .05s ease, box-shadow .2s ease;box-shadow:0 6px 16px rgba(124,92,255,.32)}
    button:hover{transform:translateY(-1px)}
    .ghost{background:#0b111a;color:var(--text);border:1px solid var(--border);box-shadow:none}
    .success{background:var(--accent-2); box-shadow:0 8px 20px rgba(23,201,100,.25)}
    .danger{background:var(--danger)}
    .pill{display:inline-block;font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;font-size:12px;color:#c5d3e0;background:#0b111a;border:1px dashed var(--border);padding:6px 10px;border-radius:999px}
    .muted{color:var(--muted)}
    .footer{margin-top:18px;color:var(--muted);font-size:12px}
    .mini{font-size:12px}
  </style>
</head>
<body>
<div class="wrap">
<h1 class="title">Renix MX — Encrypted Code</h1>
<p class="subtitle">Encode & decode text with custom <span class="pill">RX1</span> or <span class="pill">RX2</span> schemes. Not binary. Not Morse. Your own thing.</p>
<div class="grid">
<section class="card">
<h2>1) Your Text</h2>
<div class="method-row">
<label for="method">Method:</label>
<select id="method">
<option value="RX1">RX1 - Original</option>
<option value="RX2">RX2 - Alternative</option>
</select>
</div>
<textarea id="plain" placeholder="Type text here…">renix</textarea>
<div style="margin-top:12px">
<label class="mini muted" for="pass">Password for secure encryption (leave blank for simple encoding):</label>
<input id="pass" type="password" placeholder="Enter password for secure encryption" />
<div style="margin-top:8px">
<label class="mini muted">
<input type="checkbox" id="deterministic" style="width:auto;margin-right:6px"> Deterministic encryption (same input = same output)
</label>
</div>
</div>
<div class="row" style="margin-top:10px">
<button id="btn-encode">Encode →</button>
<button id="btn-decode" class="ghost">Decode ←</button>
<button id="btn-enc-sec" class="success">Encrypt →</button>
<button id="btn-dec-sec" class="ghost">Decrypt ←</button>
<button id="btn-swap" class="ghost">Swap</button>
<button id="btn-clear" class="danger">Clear</button>
</div>
</section>
<section class="card">
<h2>2) Renix MX Code</h2>
<input id="coded" type="text" placeholder="RX1:… or RX2:… or encrypted version will appear here" />
<div class="row" style="margin-top:10px">
<button id="btn-copy-coded" class="success">Copy Code</button>
<button id="btn-copy-plain" class="ghost">Copy Text</button>
</div>
<p class="mini muted" id="status"></p>
</section>
</div>
<p class="footer">© 2025 Renix MX • Made to be tiny, fast, and offline.</p>
</div>
<script>
(async function(){
// Method configurations
const METHODS = {
  RX1: {
    prefix: 'RX1:',
    prefixEnc: 'RX1E:',
    alphabet: 'R3N1X9BCDFGHJKLMPQSTUVWYZ2480567', // 32 chars
    shift: 7
  },
  RX2: {
    prefix: 'RX2:',
    prefixEnc: 'RX2E:',
    alphabet: 'Z8Y4W6V5U3T2S1QPMNLKJHGFDC9B7X0A', // 32 chars
    shift: 13
  }
};

// Build decoding maps
const DECODING = {};
Object.keys(METHODS).forEach(method => {
  const map = {};
  const alphabet = METHODS[method].alphabet;
  console.log(`${method} alphabet length:`, alphabet.length, 'chars:', alphabet);
  for(let i = 0; i < alphabet.length; i++) {
    map[alphabet[i]] = i;
  }
  DECODING[method] = map;
});

function shiftBytes(bytes, delta) {
  const out = new Uint8Array(bytes.length);
  for(let i = 0; i < bytes.length; i++) {
    out[i] = (bytes[i] + delta + 256) & 255;
  }
  return out;
}

function toBase32(bytes, alphabet) {
  if (!bytes || bytes.length === 0) return '';
  if (alphabet.length !== 32) {
    throw new Error(`Alphabet must be exactly 32 characters, got ${alphabet.length}`);
  }
  
  let out = '';
  let bitBuffer = 0, bits = 0;
  for(let i = 0; i < bytes.length; i++) {
    bitBuffer = (bitBuffer << 8) | bytes[i];
    bits += 8;
    while(bits >= 5) {
      const index = (bitBuffer >> (bits - 5)) & 31;
      out += alphabet[index];
      bits -= 5;
    }
  }
  if(bits > 0) {
    const index = (bitBuffer << (5 - bits)) & 31;
    out += alphabet[index];
  }
  while(out.length % 8 !== 0) out += '=';
  return out;
}

function fromBase32(str, decodingMap) {
  const s = str.replace(/\s+/g, '').replace(/=/g, '').toUpperCase();
  let bitBuffer = 0, bits = 0, out = [];
  for(let i = 0; i < s.length; i++) {
    const ch = s[i];
    if(!(ch in decodingMap)) throw new Error(`Invalid character: ${ch}`);
    bitBuffer = (bitBuffer << 5) | decodingMap[ch];
    bits += 5;
    if(bits >= 8) {
      bits -= 8;
      out.push((bitBuffer >> bits) & 255);
      bitBuffer &= (1 << bits) - 1;
    }
  }
  return new Uint8Array(out);
}

function encode(text, method) {
  const config = METHODS[method];
  const enc = new TextEncoder();
  const bytes = enc.encode(text);
  const shifted = shiftBytes(bytes, config.shift);
  return config.prefix + toBase32(shifted, config.alphabet);
}

function decode(code, method) {
  const config = METHODS[method];
  const prefix = config.prefix;
  if(!code.toUpperCase().startsWith(prefix)) {
    throw new Error(`Missing ${prefix} prefix`);
  }
  const body = code.slice(prefix.length);
  const shifted = fromBase32(body, DECODING[method]);
  return new TextDecoder().decode(shiftBytes(shifted, -config.shift));
}

async function deriveKey(pass, salt) {
  const enc = new TextEncoder();
  const keyMaterial = await crypto.subtle.importKey(
    'raw', enc.encode(pass), {name: 'PBKDF2'}, false, ['deriveKey']
  );
  return crypto.subtle.deriveKey(
    {name: 'PBKDF2', salt, iterations: 100000, hash: 'SHA-256'},
    keyMaterial,
    {name: 'AES-GCM', length: 256},
    false,
    ['encrypt', 'decrypt']
  );
}

function randBytes(n) {
  const a = new Uint8Array(n);
  crypto.getRandomValues(a);
  return a;
}

function concatBytes(a, b, c) {
  if (!a || !b || !c) {
    console.error('concatBytes received undefined arrays:', {a: !!a, b: !!b, c: !!c});
    return new Uint8Array(0);
  }
  const out = new Uint8Array(a.length + b.length + c.length);
  out.set(a, 0);
  out.set(b, a.length);
  out.set(c, a.length + b.length);
  return out;
}

function deterministicBytes(seed, length) {
  // Simple deterministic random generator based on seed
  const bytes = new Uint8Array(length);
  let hash = 0;
  for (let i = 0; i < seed.length; i++) {
    hash = ((hash << 5) - hash + seed.charCodeAt(i)) & 0xffffffff;
  }
  for (let i = 0; i < length; i++) {
    hash = ((hash * 1103515245) + 12345) & 0xffffffff;
    bytes[i] = (hash >>> 24) & 0xff;
  }
  return bytes;
}

async function encryptSecure(text, password, method, deterministic = false) {
  if(!password) throw new Error('Password required for secure encryption');
  if(!text) throw new Error('Text required for encryption');
  
  const config = METHODS[method];
  if (!config) throw new Error(`Invalid method: ${method}`);
  
  const enc = new TextEncoder();
  
  let salt, iv;
  if (deterministic) {
    // Use deterministic salt and IV based on text + password + method
    const seed = text + password + method;
    salt = deterministicBytes(seed, 16);
    iv = deterministicBytes(seed + 'iv', 12);
  } else {
    salt = randBytes(16);
    iv = randBytes(12);
  }
  
  if (!salt || !iv) throw new Error('Failed to generate salt/IV');
  
  try {
    const key = await deriveKey(password, salt);
    const pt = enc.encode(text);
    const ctBuf = await crypto.subtle.encrypt({name: 'AES-GCM', iv}, key, pt);
    const ctArray = new Uint8Array(ctBuf);
    
    if (!ctArray || ctArray.length === 0) throw new Error('Encryption failed');
    
    const combined = concatBytes(salt, iv, ctArray);
    if (!combined || combined.length === 0) throw new Error('Failed to combine encrypted data');
    
    const result = config.prefixEnc + toBase32(combined, config.alphabet);
    if (result.includes('undefined')) throw new Error('Encoding produced undefined values');
    
    return result;
  } catch (error) {
    console.error('Encryption error:', error);
    throw new Error(`Encryption failed: ${error.message}`);
  }
}

async function decryptSecure(code, password, method) {
  const config = METHODS[method];
  const prefix = config.prefixEnc;
  if(!code.toUpperCase().startsWith(prefix)) {
    throw new Error(`Missing ${prefix} prefix`);
  }
  if(!password) throw new Error('Password required');
  const body = code.slice(prefix.length);
  const all = fromBase32(body, DECODING[method]);
  if(all.length < 16 + 12 + 16) throw new Error('Encrypted data too short');
  const salt = all.slice(0, 16);
  const iv = all.slice(16, 28);
  const ct = all.slice(28);
  const key = await deriveKey(password, salt);
  try {
    const ptBuf = await crypto.subtle.decrypt({name: 'AES-GCM', iv}, key, ct);
    return new TextDecoder().decode(ptBuf);
  } catch(e) {
    throw new Error('Decryption failed (wrong password or corrupted data)');
  }
}

function detectMethod(code) {
  const upper = code.toUpperCase();
  for(const method of Object.keys(METHODS)) {
    const config = METHODS[method];
    if(upper.startsWith(config.prefix) || upper.startsWith(config.prefixEnc)) {
      return method;
    }
  }
  return null;
}

const $ = (sel) => document.querySelector(sel);
const plain = $('#plain');
const coded = $('#coded');
const pass = $('#pass');
const status = $('#status');
const methodSelect = $('#method');
const deterministicCheckbox = $('#deterministic');

function flash(msg, ok = true) {
  status.textContent = msg;
  status.style.color = ok ? 'var(--accent-2)' : 'var(--danger)';
  clearTimeout(flash._t);
  flash._t = setTimeout(() => {
    status.textContent = '';
  }, 2500);
}

function getCurrentMethod() {
  return methodSelect.value;
}

$('#btn-encode').addEventListener('click', () => {
  try {
    coded.value = encode(plain.value, getCurrentMethod());
    flash('Encoded ✓');
  } catch(e) {
    flash(e.message, false);
  }
});

$('#btn-decode').addEventListener('click', () => {
  try {
    const detectedMethod = detectMethod(coded.value);
    if(detectedMethod) {
      methodSelect.value = detectedMethod;
      plain.value = decode(coded.value, detectedMethod);
      flash(`Decoded (${detectedMethod}) ✓`);
    } else {
      plain.value = decode(coded.value, getCurrentMethod());
      flash('Decoded ✓');
    }
  } catch(e) {
    flash(e.message, false);
  }
});

$('#btn-enc-sec').addEventListener('click', async () => {
  try {
    const isDeterministic = deterministicCheckbox.checked;
    coded.value = await encryptSecure(plain.value, pass.value, getCurrentMethod(), isDeterministic);
    flash(`Encrypted ${isDeterministic ? '(deterministic)' : ''} ✓`);
  } catch(e) {
    flash(e.message, false);
  }
});

$('#btn-dec-sec').addEventListener('click', async () => {
  try {
    const detectedMethod = detectMethod(coded.value);
    if(detectedMethod) {
      methodSelect.value = detectedMethod;
      plain.value = await decryptSecure(coded.value, pass.value, detectedMethod);
      flash(`Decrypted (${detectedMethod}) ✓`);
    } else {
      plain.value = await decryptSecure(coded.value, pass.value, getCurrentMethod());
      flash('Decrypted ✓');
    }
  } catch(e) {
    flash(e.message, false);
  }
});

$('#btn-swap').addEventListener('click', () => {
  const a = plain.value;
  plain.value = coded.value;
  coded.value = a;
  flash('Swapped');
});

$('#btn-clear').addEventListener('click', () => {
  plain.value = '';
  coded.value = '';
  flash('Cleared');
});

$('#btn-copy-coded').addEventListener('click', async () => {
  try {
    await navigator.clipboard.writeText(coded.value);
    flash('Code copied');
  } catch {
    flash('Clipboard blocked', false);
  }
});

$('#btn-copy-plain').addEventListener('click', async () => {
  try {
    await navigator.clipboard.writeText(plain.value);
    flash('Text copied');
  } catch {
    flash('Clipboard blocked', false);
  }
});

// Auto-encode on method change
methodSelect.addEventListener('change', () => {
  if(plain.value) {
    try {
      coded.value = encode(plain.value, getCurrentMethod());
      flash(`Switched to ${getCurrentMethod()}`);
    } catch(e) {
      flash(e.message, false);
    }
  }
});

// Initialize
coded.value = encode(plain.value, getCurrentMethod());

})();
</script>
</body>
</html>
